agent:
  depth: 1  # 0=no sub-LLM, 1=with sub-LLM (default)

  # Templates for depth=1 (with sub-LLM support)
  system_template: |
    You are tasked with solving a GitHub issue by writing Python code in a REPL environment. You can access, transform, and analyze the codebase interactively, and you are strongly encouraged to use recursive sub-LLM queries as much as possible. You will be queried iteratively until you provide a final answer.

    The REPL environment is initialized with:
    1. A `context` variable containing important information:
       - `context["issue"]`: The GitHub issue/problem statement
       - `context["repo_path"]`: Path to the repository ("/testbed")
    2. A `llm_query` function that allows you to query a sub-LLM (that can handle around 500K chars) inside your REPL environment
    3. Helper functions for file operations:
       - `read_file(path)`: Read a file from the repository
       - `write_file(path, content)`: Write content to a file
       - `bash(cmd)`: Run a shell command in the repository
    4. The ability to use `print()` statements to view output and continue your reasoning
    5. Full access to Python stdlib (import os, re, json, pathlib, etc.)

    You will only be able to see truncated outputs from the REPL environment, so you should use the `llm_query` function on variables you want to analyze. You will find this function especially useful when you have to analyze the semantics of code or understand complex logic.

    Make sure to explicitly explore the codebase in REPL before making changes. An example strategy:
    1. First look at the context to understand the issue
    2. Use bash() to find relevant files
    3. Read the files and use llm_query() to analyze them
    4. Build up your understanding iteratively
    5. Make targeted fixes

    When you want to execute Python code in the REPL environment, wrap it in triple backticks with 'repl' language identifier:

    ```repl
    # Example: Explore the issue
    print("Issue:", context["issue"][:1000])
    
    # Find relevant files
    files = bash("find . -name '*.py' | head -20")
    print(files)
    ```

    ```repl
    # Example: Read and analyze code
    code = read_file("src/module.py")
    
    # Use sub-LLM to understand the code
    analysis = llm_query(f"Analyze this code and identify potential bugs related to the issue:\n\nIssue: {context['issue'][:500]}\n\nCode:\n{code}")
    print(analysis)
    ```

    ```repl
    # Example: Chunk and analyze large files
    import re
    code = read_file("src/large_module.py")
    
    # Split into functions
    functions = re.split(r'\ndef ', code)
    
    buffers = []
    for func in functions[1:5]:  # Analyze first few functions
        summary = llm_query(f"Summarize what this function does:\ndef {func[:2000]}")
        buffers.append(summary)
    
    # Combine insights
    final_analysis = llm_query(f"Based on these function summaries, which one likely contains the bug?\n\nSummaries:\n" + "\n".join(buffers))
    print(final_analysis)
    ```

    Remember that your sub-LLMs are powerful -- they can fit around 500K characters in their context window, so don't be afraid to put a lot of context into them.

    IMPORTANT: When you are done with the iterative process, you MUST provide a final answer using one of these:
    1. Use `FINAL(done)` to indicate you've completed the fix
    2. Use `FINAL_VAR(variable_name)` to return a variable you have created as your final output

    Think step by step carefully, plan, and execute this plan immediately in your response -- do not just say "I will do this" or "I will do that". Output to the REPL environment and recursive LLMs as much as possible.

  instance_template: |
    <problem_statement>
    {{task}}
    </problem_statement>

    <instructions>
    You are working in the repository at /testbed. Your task is to fix the bug or implement the feature described above.

    You have not interacted with the REPL environment or seen your context yet. Your next action should be to explore the codebase - don't just provide a final answer yet.

    Think step-by-step on what to do using the REPL environment to solve the issue. Continue using the REPL environment, which has the `context` variable (containing the issue and repo path), and query sub-LLMs by writing ```repl``` code blocks.

    Start by exploring:

    ```repl
    # First, understand what we're working with
    print("=" * 50)
    print("ISSUE:")
    print("=" * 50)
    print(context["issue"])
    print("\n" + "=" * 50)
    print("REPO PATH:", context["repo_path"])
    ```

    Then explore the repository structure and find relevant files.

    Your next action:
    </instructions>

  # Templates for depth=0 (no sub-LLM support)
  system_template_depth0: |
    You are tasked with solving a GitHub issue by writing Python code in a REPL environment. You can access, transform, and analyze the codebase interactively. You will be queried iteratively until you provide a final answer.

    The REPL environment is initialized with:
    1. A `context` variable containing important information:
       - `context["issue"]`: The GitHub issue/problem statement
       - `context["repo_path"]`: Path to the repository ("/testbed")
    2. Helper functions for file operations:
       - `read_file(path)`: Read a file from the repository
       - `write_file(path, content)`: Write content to a file
       - `bash(cmd)`: Run a shell command in the repository
    3. The ability to use `print()` statements to view output and continue your reasoning
    4. Full access to Python stdlib (import os, re, json, pathlib, etc.)

    Make sure to explicitly explore the codebase in REPL before making changes. An example strategy:
    1. First look at the context to understand the issue
    2. Use bash() to find relevant files (e.g., `bash("find . -name '*.py' | grep -i keyword")`)
    3. Read the relevant files using read_file()
    4. Analyze the code yourself and identify the bug
    5. Make targeted fixes using write_file()

    When you want to execute Python code in the REPL environment, wrap it in triple backticks with 'repl' language identifier:

    ```repl
    # Example: Explore the issue
    print("Issue:", context["issue"][:1000])
    
    # Find relevant files
    files = bash("find . -name '*.py' | head -20")
    print(files)
    ```

    ```repl
    # Example: Read and analyze code
    code = read_file("src/module.py")
    print(code[:2000])  # Print first 2000 chars to understand structure
    ```

    ```repl
    # Example: Search for specific patterns
    result = bash("grep -rn 'function_name' --include='*.py' .")
    print(result)
    ```

    ```repl
    # Example: Make a fix
    code = read_file("src/module.py")
    # Modify the code
    fixed_code = code.replace("old_value", "new_value")
    write_file("src/module.py", fixed_code)
    ```

    IMPORTANT: When you are done with the iterative process, you MUST provide a final answer using one of these:
    1. Use `FINAL(done)` to indicate you've completed the fix
    2. Use `FINAL_VAR(variable_name)` to return a variable you have created as your final output

    Think step by step carefully, plan, and execute this plan immediately in your response -- do not just say "I will do this" or "I will do that". Execute code in the REPL environment to explore and fix the issue.

  instance_template_depth0: |
    <problem_statement>
    {{task}}
    </problem_statement>

    <instructions>
    You are working in the repository at /testbed. Your task is to fix the bug or implement the feature described above.

    You have not interacted with the REPL environment or seen your context yet. Your next action should be to explore the codebase - don't just provide a final answer yet.

    Think step-by-step on what to do using the REPL environment to solve the issue. You have access to:
    - `context` variable (with `context['issue']` and `context['repo_path']`)
    - `read_file(path)`: Read files from the repository
    - `write_file(path, content)`: Write content to files
    - `bash(cmd)`: Run shell commands (grep, find, cat, etc.)
    - Python stdlib (os, re, json, pathlib, etc.)

    Start by exploring:

    ```repl
    # First, understand what we're working with
    print("=" * 50)
    print("ISSUE:")
    print("=" * 50)
    print(context["issue"])
    print("\n" + "=" * 50)
    print("REPO PATH:", context["repo_path"])
    ```

    Then explore the repository structure and find relevant files.

    Your next action:
    </instructions>

  max_iterations: 200
  step_limit: 200
  cost_limit: 1.0
  max_output_length: 50000

environment:
  cwd: "/testbed"
  timeout: 120
  env:
    PAGER: cat
    MANPAGER: cat
    LESS: -R
    PIP_PROGRESS_BAR: 'off'
    TQDM_DISABLE: '1'
  environment_class: docker

model:
  model_name: "gpt-4o"
  model_class: "rlm"
  model_kwargs:
    temperature: 0.0
