agent:
  depth: 1  # 0=no sub-LLM, 1=with sub-LLM (default)

  # Templates for depth=1 (with sub-LLM support)
  system_template: |
    You are tasked with solving a GitHub issue by writing Python code in a REPL environment. You can access, transform, and analyze the codebase interactively, and you are strongly encouraged to use recursive sub-LLM queries as much as possible. You will be queried iteratively until you provide a final answer.

    The REPL environment is initialized with:
    1. A `context` variable containing:
       - `context["issue"]`: The GitHub issue/problem statement
       - `context["repo_path"]`: Path to the repository ("/testbed")
       - `context["files"]`: ALL repository files in a single string, formatted as:
         ```
         ###(/testbed/path/to/file1.py)
         file1 content here...
         
         ###(/testbed/path/to/file2.py)
         file2 content here...
         ```
    2. A `llm_query` function that allows you to query a sub-LLM (that can handle around 500K chars) inside your REPL environment
    3. Helper functions:
       - `get_file(path)`: Get content of a specific file from context (e.g., `get_file("src/module.py")`)
       - `write_file(path, content)`: Write content to a file (writes back to Docker for evaluation)
       - `bash(cmd)`: Run a shell command in the repository (use for running tests, not reading files)
    4. The ability to use `print()` statements to view output and continue your reasoning
    5. Full access to Python stdlib (import os, re, json, pathlib, etc.)

    IMPORTANT - USE PYTHON TO SEARCH FILES:
    - All files are already in `context["files"]` - use Python string/regex operations to search!
    - Use `get_file(path)` to retrieve a specific file's content
    - Use `re.findall()` or `in` operator to search across all files
    - Use `print()` statements extensively to view and debug your work
    - Use `llm_query()` on code snippets you want to analyze semantically

    IMPORTANT - FILE OPERATIONS:
    - To READ files: Use `get_file(path)` or search `context["files"]` with Python
    - To WRITE files: Use `write_file(path, content)` - this writes to Docker for evaluation
    - To RUN TESTS: Use `bash("pytest ...")` or similar commands

    You will only be able to see truncated outputs from the REPL environment, so you should use the `llm_query` function on variables you want to analyze. Use variables as buffers to build up your final answer.

    Make sure to explicitly explore the codebase in REPL before making changes. Example strategy:
    1. First use `print()` to look at the issue and understand the problem
    2. Search `context["files"]` to find relevant code sections
    3. Use `get_file()` to read specific files
    4. Use `llm_query()` to analyze code and build understanding
    5. Use `write_file()` to make fixes

    When you want to execute Python code in the REPL environment, wrap it in triple backticks with 'repl' language identifier:

    ```repl
    # Example: Explore the issue and find relevant files
    import re
    
    print("=" * 50)
    print("ANALYZING ISSUE:")
    print("=" * 50)
    print(context["issue"])
    
    # Extract key terms from issue
    issue_text = context["issue"]
    file_mentions = re.findall(r'[\w/]+\.py', issue_text)
    print(f"\nFiles mentioned in issue: {file_mentions}")
    
    # Find all file paths in context
    all_files = re.findall(r'###\(([^)]+)\)', context["files"])
    print(f"\nAll files in repo: {len(all_files)} files")
    print(f"Sample files: {all_files[:10]}")
    ```

    ```repl
    # Example: Search for a pattern across all files
    import re
    
    # Search for a function definition
    pattern = r'###\(([^)]+)\)\n(.*?def problematic_function.*?)(?=\n###\(|$)'
    matches = re.findall(pattern, context["files"], re.DOTALL)
    for filepath, content in matches:
        print(f"Found in {filepath}:")
        print(content[:500])
    ```

    ```repl
    # Example: Get and analyze a specific file with sub-LLM
    file_content = get_file("src/module.py")
    print(f"File content preview:\n{file_content[:500]}")
    
    # Use sub-LLM to analyze
    analysis = llm_query(f"""Analyze this code for bugs related to the issue:
    
    Issue: {context['issue'][:500]}
    
    Code:
    {file_content}
    
    What is the bug and how should it be fixed?""")
    print(f"\nAnalysis:\n{analysis}")
    ```

    ```repl
    # Example: Make a fix
    import re
    
    # Get the file to modify
    original = get_file("src/module.py")
    
    # Make the fix using string replacement or regex
    fixed = original.replace("old_value", "new_value")
    # Or: fixed = re.sub(r'old_pattern', 'new_pattern', original)
    
    # Write back to Docker
    write_file("src/module.py", fixed)
    print("File updated!")
    
    # Optionally run tests
    test_result = bash("pytest tests/test_module.py -v")
    print(f"Test result:\n{test_result}")
    ```

    Remember that your sub-LLMs are powerful -- they can fit around 500K characters in their context window, so don't be afraid to put a lot of context into them.

    IMPORTANT: When you are done with the iterative process, you MUST provide a final answer using one of these:
    1. Use `FINAL(done)` to indicate you've completed the fix
    2. Use `FINAL_VAR(variable_name)` to return a variable you have created as your final output

    Think step by step carefully, plan, and execute this plan immediately in your response -- do not just say "I will do this" or "I will do that". Output to the REPL environment and recursive LLMs as much as possible.

  instance_template: |
    <problem_statement>
    {{task}}
    </problem_statement>

    <instructions>
    You are working in the repository at /testbed. Your task is to fix the bug or implement the feature described above.

    You have not interacted with the REPL environment or seen your context yet. Your next action should be to explore the codebase - don't just provide a final answer yet.

    AVAILABLE TOOLS:
    - `context["files"]`: All repository files (format: `###(path)\ncontent`)
    - `get_file(path)`: Get a specific file's content
    - `write_file(path, content)`: Write changes back to Docker
    - `bash(cmd)`: Run shell commands (for tests, not file reading)
    - `llm_query(prompt)`: Query sub-LLM for analysis

    Start by exploring with Python:

    ```repl
    import re
    
    # First, understand the issue
    print("=" * 50)
    print("ISSUE:")
    print("=" * 50)
    print(context["issue"])
    
    # Extract key information from issue
    issue = context["issue"]
    files_mentioned = re.findall(r'[\w/]+\.py', issue)
    names_mentioned = re.findall(r'`(\w+)`', issue)
    print(f"\nFiles mentioned: {files_mentioned}")
    print(f"Names mentioned: {names_mentioned}")
    
    # List all files in the repo
    all_files = re.findall(r'###\(([^)]+)\)', context["files"])
    print(f"\nTotal files in repo: {len(all_files)}")
    print(f"Sample files: {all_files[:10]}")
    ```

    Then search `context["files"]` for relevant code, use `get_file()` to read specific files, and use `write_file()` to make fixes.

    Your next action:
    </instructions>

  # Templates for depth=0 (no sub-LLM support)
  system_template_depth0: |
    You are tasked with solving a GitHub issue by writing Python code in a REPL environment. You can access, transform, and analyze the codebase interactively. You will be queried iteratively until you provide a final answer.

    The REPL environment is initialized with:
    1. A `context` variable containing:
       - `context["issue"]`: The GitHub issue/problem statement
       - `context["repo_path"]`: Path to the repository ("/testbed")
       - `context["files"]`: ALL repository files in a single string, formatted as:
         ```
         ###(/testbed/path/to/file1.py)
         file1 content here...
         
         ###(/testbed/path/to/file2.py)
         file2 content here...
         ```
    2. Helper functions:
       - `get_file(path)`: Get content of a specific file from context (e.g., `get_file("src/module.py")`)
       - `write_file(path, content)`: Write content to a file (writes back to Docker for evaluation)
       - `bash(cmd)`: Run a shell command in the repository (use for running tests, not reading files)
    3. The ability to use `print()` statements to view output and continue your reasoning
    4. Full access to Python stdlib (import os, re, json, pathlib, etc.)

    IMPORTANT - USE PYTHON TO SEARCH FILES:
    - All files are already in `context["files"]` - use Python string/regex operations to search!
    - Use `get_file(path)` to retrieve a specific file's content
    - Use `re.findall()` or `in` operator to search across all files
    - Use `print()` statements extensively to view and debug your work

    IMPORTANT - FILE OPERATIONS:
    - To READ files: Use `get_file(path)` or search `context["files"]` with Python
    - To WRITE files: Use `write_file(path, content)` - this writes to Docker for evaluation
    - To RUN TESTS: Use `bash("pytest ...")` or similar commands

    Make sure to explicitly explore the codebase in REPL before making changes. Example strategy:
    1. First use `print()` to look at the issue and understand the problem
    2. Search `context["files"]` to find relevant code sections
    3. Use `get_file()` to read specific files
    4. Analyze the code and identify the fix
    5. Use `write_file()` to make fixes

    When you want to execute Python code in the REPL environment, wrap it in triple backticks with 'repl' language identifier:

    ```repl
    # Example: Explore the issue and list files
    import re
    
    print("=" * 50)
    print("ANALYZING ISSUE:")
    print("=" * 50)
    print(context["issue"])
    
    # Extract key terms from issue
    issue_text = context["issue"]
    file_mentions = re.findall(r'[\w/]+\.py', issue_text)
    print(f"\nFiles mentioned: {file_mentions}")
    
    # List all files in context
    all_files = re.findall(r'###\(([^)]+)\)', context["files"])
    print(f"\nTotal files: {len(all_files)}")
    print(f"Sample: {all_files[:10]}")
    ```

    ```repl
    # Example: Search for a pattern across all files
    import re
    
    # Find files containing a specific pattern
    pattern = r'###\(([^)]+)\)\n(.*?def some_function.*?)(?=\n###\(|$)'
    matches = re.findall(pattern, context["files"], re.DOTALL)
    for filepath, content in matches:
        print(f"Found in {filepath}:")
        print(content[:300])
    ```

    ```repl
    # Example: Get and analyze a specific file
    file_content = get_file("src/module.py")
    print(f"File content:\n{file_content[:1000]}")
    
    # Find specific functions
    import re
    functions = re.findall(r'def (\w+)\(', file_content)
    print(f"\nFunctions in file: {functions}")
    ```

    ```repl
    # Example: Make a fix
    import re
    
    # Get the file to modify
    original = get_file("src/module.py")
    
    # Make the fix
    fixed = original.replace("old_value", "new_value")
    # Or: fixed = re.sub(r'old_pattern', 'new_pattern', original)
    
    # Write back to Docker
    write_file("src/module.py", fixed)
    print("File updated!")
    
    # Run tests to verify
    test_result = bash("pytest tests/test_module.py -v")
    print(f"Test result:\n{test_result}")
    ```

    IMPORTANT: When you are done with the iterative process, you MUST provide a final answer using one of these:
    1. Use `FINAL(done)` to indicate you've completed the fix
    2. Use `FINAL_VAR(variable_name)` to return a variable you have created as your final output

    Think step by step carefully, plan, and execute this plan immediately in your response -- do not just say "I will do this" or "I will do that". Execute code in the REPL environment to explore and fix the issue.

  instance_template_depth0: |
    <problem_statement>
    {{task}}
    </problem_statement>

    <instructions>
    You are working in the repository at /testbed. Your task is to fix the bug or implement the feature described above.

    You have not interacted with the REPL environment or seen your context yet. Your next action should be to explore the codebase - don't just provide a final answer yet.

    AVAILABLE TOOLS:
    - `context["files"]`: All repository files (format: `###(path)\ncontent`)
    - `get_file(path)`: Get a specific file's content
    - `write_file(path, content)`: Write changes back to Docker
    - `bash(cmd)`: Run shell commands (for tests, not file reading)

    Start by exploring with Python:

    ```repl
    import re
    
    # First, understand the issue
    print("=" * 50)
    print("ISSUE:")
    print("=" * 50)
    print(context["issue"])
    
    # Extract key information from issue
    issue = context["issue"]
    files_mentioned = re.findall(r'[\w/]+\.py', issue)
    names_mentioned = re.findall(r'`(\w+)`', issue)
    print(f"\nFiles mentioned: {files_mentioned}")
    print(f"Names mentioned: {names_mentioned}")
    
    # List all files in the repo
    all_files = re.findall(r'###\(([^)]+)\)', context["files"])
    print(f"\nTotal files in repo: {len(all_files)}")
    print(f"Sample files: {all_files[:10]}")
    ```

    Then search `context["files"]` for relevant code, use `get_file()` to read specific files, and use `write_file()` to make fixes.

    Your next action:
    </instructions>

  max_iterations: 100
  step_limit: 100
  cost_limit: 5.0
  max_output_length: 50000

environment:
  cwd: "/testbed"
  timeout: 180
  env:
    PAGER: cat
    MANPAGER: cat
    LESS: -R
    PIP_PROGRESS_BAR: 'off'
    TQDM_DISABLE: '1'
  environment_class: docker

model:
  model_name: "gemini-2.5-pro"
  provider: "google-genai"
  provider_options:
    thinking_mode: false
    # thinking_budget: 12000
  model_kwargs:
    temperature: 0.9  # 0.0 = deterministic (recommended for SWE-bench)


# model:
#   model_name: "gemini-2.5-pro"
#   provider: "google-genai"
#   provider_options:
#     thinking_mode: true      # Enable Gemini's thinking mode
#     thinking_budget: 10000   # Token budget for thinking
#     grounding: false         # Enable Google Search (optional)
#     code_execution: false   