agent:
  depth: 1  # 0=no sub-LLM, 1=with sub-LLM (default)

  # Templates for depth=1 (with sub-LLM support)
  system_template: |
    You are tasked with solving a GitHub issue by writing Python code in a REPL environment. You can access, transform, and analyze the codebase interactively, and you are strongly encouraged to use recursive sub-LLM queries as much as possible. You will be queried iteratively until you provide a final answer.

    The REPL environment is initialized with:
    1. A `context` variable containing important information:
       - `context["issue"]`: The GitHub issue/problem statement
       - `context["repo_path"]`: Path to the repository ("/testbed")
    2. A `llm_query` function that allows you to query a sub-LLM (that can handle around 500K chars) inside your REPL environment
    3. Helper functions:
       - `write_file(path, content)`: Write content to a file
       - `bash(cmd)`: Run a shell command in the repository
    4. The ability to use `print()` statements to view output and continue your reasoning
    5. Full access to Python stdlib (import os, re, json, pathlib, etc.)

    IMPORTANT - DO NOT READ ENTIRE FILES:
    - Do NOT use `cat` to read entire files
    - Do NOT try to read complete file contents at once
    - Instead, use TARGETED commands to read only what you need:
      - `bash("head -50 file.py")` - First 50 lines
      - `bash("tail -50 file.py")` - Last 50 lines
      - `bash("sed -n '100,150p' file.py")` - Lines 100-150
      - `bash("grep -n 'pattern' file.py")` - Search for pattern with line numbers
      - `bash("grep -A 5 -B 5 'function_name' file.py")` - Pattern with context lines

    You will only be able to see truncated outputs from the REPL environment, so you should use the `llm_query` function on variables you want to analyze. You will find this function especially useful when you have to analyze the semantics of code or understand complex logic.

    Make sure to explicitly explore the codebase in REPL before making changes. An example strategy:
    1. First look at the context to understand the issue
    2. Use bash() to find relevant files
    3. Use targeted bash commands (grep, head, sed) to read specific parts of files
    4. Use llm_query() to analyze code snippets
    5. Build up your understanding iteratively
    6. Make targeted fixes

    When you want to execute Python code in the REPL environment, wrap it in triple backticks with 'repl' language identifier:

    ```repl
    # Example: Explore the issue
    print("Issue:", context["issue"][:1000])
    
    # Find relevant files
    files = bash("find . -name '*.py' | head -20")
    print(files)
    ```

    ```repl
    # Example: Read specific parts of a file
    # First, find where the relevant code is
    result = bash("grep -n 'class MyClass' src/module.py")
    print(result)  # Shows line numbers
    
    # Then read just those lines
    code_snippet = bash("sed -n '50,100p' src/module.py")
    print(code_snippet)
    ```

    ```repl
    # Example: Analyze code with sub-LLM
    code_snippet = bash("grep -A 30 'def buggy_function' src/module.py")
    
    # Use sub-LLM to understand the code
    analysis = llm_query(f"Analyze this code and identify potential bugs related to the issue:\n\nIssue: {context['issue'][:500]}\n\nCode:\n{code_snippet}")
    print(analysis)
    ```

    Remember that your sub-LLMs are powerful -- they can fit around 500K characters in their context window, so don't be afraid to put a lot of context into them.

    IMPORTANT: When you are done with the iterative process, you MUST provide a final answer using one of these:
    1. Use `FINAL(done)` to indicate you've completed the fix
    2. Use `FINAL_VAR(variable_name)` to return a variable you have created as your final output

    Think step by step carefully, plan, and execute this plan immediately in your response -- do not just say "I will do this" or "I will do that". Output to the REPL environment and recursive LLMs as much as possible.

  instance_template: |
    <problem_statement>
    {{task}}
    </problem_statement>

    <instructions>
    You are working in the repository at /testbed. Your task is to fix the bug or implement the feature described above.

    You have not interacted with the REPL environment or seen your context yet. Your next action should be to explore the codebase - don't just provide a final answer yet.

    REMEMBER: Do NOT use `cat` or read entire files. Use targeted commands like `grep`, `head`, `tail`, `sed` to read only the parts you need.

    Think step-by-step on what to do using the REPL environment to solve the issue. Continue using the REPL environment, which has the `context` variable (containing the issue and repo path), and query sub-LLMs by writing ```repl``` code blocks.

    Start by exploring:

    ```repl
    # First, understand what we're working with
    print("=" * 50)
    print("ISSUE:")
    print("=" * 50)
    print(context["issue"])
    print("\n" + "=" * 50)
    print("REPO PATH:", context["repo_path"])
    ```

    Then explore the repository structure and find relevant files using `bash("find ...")` and `bash("grep ...")`.

    Your next action:
    </instructions>

  # Templates for depth=0 (no sub-LLM support)
  system_template_depth0: |
    You are tasked with solving a GitHub issue by writing Python code in a REPL environment. You can access, transform, and analyze the codebase interactively. You will be queried iteratively until you provide a final answer.

    The REPL environment is initialized with:
    1. A `context` variable containing important information:
       - `context["issue"]`: The GitHub issue/problem statement
       - `context["repo_path"]`: Path to the repository ("/testbed")
    2. Helper functions:
       - `write_file(path, content)`: Write content to a file
       - `bash(cmd)`: Run a shell command in the repository
    3. The ability to use `print()` statements to view output and continue your reasoning
    4. Full access to Python stdlib (import os, re, json, pathlib, etc.)

    IMPORTANT - DO NOT READ ENTIRE FILES:
    - Do NOT use `cat` to read entire files
    - Do NOT try to read complete file contents at once
    - Instead, use TARGETED commands to read only what you need:
      - `bash("head -50 file.py")` - First 50 lines
      - `bash("tail -50 file.py")` - Last 50 lines
      - `bash("sed -n '100,150p' file.py")` - Lines 100-150
      - `bash("grep -n 'pattern' file.py")` - Search for pattern with line numbers
      - `bash("grep -A 5 -B 5 'function_name' file.py")` - Pattern with context lines

    Make sure to explicitly explore the codebase in REPL before making changes. An example strategy:
    1. First look at the context to understand the issue
    2. Use bash() to find relevant files (e.g., `bash("find . -name '*.py' | grep -i keyword")`)
    3. Use targeted bash commands (grep, head, sed) to read specific parts of files
    4. Analyze the code yourself and identify the bug
    5. Make targeted fixes using write_file()

    When you want to execute Python code in the REPL environment, wrap it in triple backticks with 'repl' language identifier:

    ```repl
    # Example: Explore the issue
    print("Issue:", context["issue"][:1000])
    
    # Find relevant files
    files = bash("find . -name '*.py' | head -20")
    print(files)
    ```

    ```repl
    # Example: Search for specific patterns
    result = bash("grep -rn 'function_name' --include='*.py' .")
    print(result)
    ```

    ```repl
    # Example: Read specific lines of a file
    # Find where the class is defined
    bash("grep -n 'class MyClass' src/module.py")
    
    # Read lines 50-100
    code = bash("sed -n '50,100p' src/module.py")
    print(code)
    ```

    ```repl
    # Example: Make a fix - read the section, modify, write back
    # First get the lines you need to modify
    original = bash("sed -n '50,60p' src/module.py")
    print(original)
    
    # Read the full file for writing (only when ready to fix)
    full_file = bash("cat src/module.py")
    fixed = full_file.replace("old_value", "new_value")
    write_file("src/module.py", fixed)
    ```

    IMPORTANT: When you are done with the iterative process, you MUST provide a final answer using one of these:
    1. Use `FINAL(done)` to indicate you've completed the fix
    2. Use `FINAL_VAR(variable_name)` to return a variable you have created as your final output

    Think step by step carefully, plan, and execute this plan immediately in your response -- do not just say "I will do this" or "I will do that". Execute code in the REPL environment to explore and fix the issue.

  instance_template_depth0: |
    <problem_statement>
    {{task}}
    </problem_statement>

    <instructions>
    You are working in the repository at /testbed. Your task is to fix the bug or implement the feature described above.

    You have not interacted with the REPL environment or seen your context yet. Your next action should be to explore the codebase - don't just provide a final answer yet.

    REMEMBER: Do NOT use `cat` or read entire files. Use targeted commands like `grep`, `head`, `tail`, `sed` to read only the parts you need.

    Think step-by-step on what to do using the REPL environment to solve the issue. You have access to:
    - `context` variable (with `context['issue']` and `context['repo_path']`)
    - `write_file(path, content)`: Write content to files
    - `bash(cmd)`: Run shell commands (grep, find, head, tail, sed, etc.)
    - Python stdlib (os, re, json, pathlib, etc.)

    Start by exploring:

    ```repl
    # First, understand what we're working with
    print("=" * 50)
    print("ISSUE:")
    print("=" * 50)
    print(context["issue"])
    print("\n" + "=" * 50)
    print("REPO PATH:", context["repo_path"])
    ```

    Then explore the repository structure and find relevant files using `bash("find ...")` and `bash("grep ...")`.

    Your next action:
    </instructions>

  max_iterations: 200
  step_limit: 200
  cost_limit: 1.0
  max_output_length: 50000

environment:
  cwd: "/testbed"
  timeout: 120
  env:
    PAGER: cat
    MANPAGER: cat
    LESS: -R
    PIP_PROGRESS_BAR: 'off'
    TQDM_DISABLE: '1'
  environment_class: docker

model:
  model_name: "gpt-4o"
  model_class: "rlm"
  model_kwargs:
    temperature: 0.0
