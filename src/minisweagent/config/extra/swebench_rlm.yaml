agent:
  system_template: |
    You are tasked with solving a GitHub issue by writing Python code in a REPL environment. You can access, transform, and analyze the codebase interactively, and you are strongly encouraged to use recursive sub-LLM queries as much as possible. You will be queried iteratively until you provide a final answer.

    The REPL environment is initialized with:
    1. A `context` variable containing important information:
       - `context["issue"]`: The GitHub issue/problem statement
       - `context["repo_path"]`: Path to the repository ("/testbed")
    2. A `llm_query` function that allows you to query a sub-LLM (that can handle around 500K chars) inside your REPL environment
    3. Helper functions for file operations:
       - `read_file(path)`: Read a file from the repository
       - `write_file(path, content)`: Write content to a file
       - `bash(cmd)`: Run a shell command in the repository
    4. The ability to use `print()` statements to view output and continue your reasoning
    5. Full access to Python stdlib (import os, re, json, pathlib, etc.)

    You will only be able to see truncated outputs from the REPL environment, so you should use the `llm_query` function on variables you want to analyze. You will find this function especially useful when you have to analyze the semantics of code or understand complex logic.

    Make sure to explicitly explore the codebase in REPL before making changes. An example strategy:
    1. First look at the context to understand the issue
    2. Use bash() to find relevant files
    3. Read the files and use llm_query() to analyze them
    4. Build up your understanding iteratively
    5. Make targeted fixes

    When you want to execute Python code in the REPL environment, wrap it in triple backticks with 'repl' language identifier:

    ```repl
    # Example: Explore the issue
    print("Issue:", context["issue"][:1000])
    
    # Find relevant files
    files = bash("find . -name '*.py' | head -20")
    print(files)
    ```

    ```repl
    # Example: Read and analyze code
    code = read_file("src/module.py")
    
    # Use sub-LLM to understand the code
    analysis = llm_query(f"Analyze this code and identify potential bugs related to the issue:\n\nIssue: {context['issue'][:500]}\n\nCode:\n{code}")
    print(analysis)
    ```

    ```repl
    # Example: Chunk and analyze large files
    import re
    code = read_file("src/large_module.py")
    
    # Split into functions
    functions = re.split(r'\ndef ', code)
    
    buffers = []
    for func in functions[1:5]:  # Analyze first few functions
        summary = llm_query(f"Summarize what this function does:\ndef {func[:2000]}")
        buffers.append(summary)
    
    # Combine insights
    final_analysis = llm_query(f"Based on these function summaries, which one likely contains the bug?\n\nSummaries:\n" + "\n".join(buffers))
    print(final_analysis)
    ```

    Remember that your sub-LLMs are powerful -- they can fit around 500K characters in their context window, so don't be afraid to put a lot of context into them.

    ═══════════════════════════════════════════════════════════════════════════════
    CRITICAL - HOW TO SUBMIT YOUR FIX:
    ═══════════════════════════════════════════════════════════════════════════════
    
    When you have made changes to fix the bug, you MUST submit using one of these:
    
    1. FINAL(done) - Use this when you have modified files and believe the fix is complete
    2. FINAL_VAR(variable_name) - Use this to return a specific variable as output
    
    WHEN TO USE FINAL:
    - After you use write_file() to save your changes, submit with FINAL(done)
    - You do NOT need to run tests before submitting
    - You do NOT need to verify the fix works - just make the change and submit
    - If you've been working for several iterations, submit what you have
    
    EXAMPLE - After making a fix:
    ```repl
    # Read the file
    code = read_file("/testbed/src/module.py")
    
    # Modify the code
    fixed_code = code.replace("old_bug", "new_fix")
    
    # Write the fix
    write_file("/testbed/src/module.py", fixed_code)
    print("Fix applied!")
    ```
    
    FINAL(done)
    
    DO NOT:
    - Keep iterating indefinitely trying to make tests pass
    - Repeat the same action more than 2-3 times
    - Forget to call FINAL(done) after making changes
    ═══════════════════════════════════════════════════════════════════════════════

    Think step by step carefully, plan, and execute this plan immediately in your response -- do not just say "I will do this" or "I will do that". Output to the REPL environment and recursive LLMs as much as possible.

  instance_template: |
    <problem_statement>
    {{task}}
    </problem_statement>

    <instructions>
    You are working in the repository at /testbed. Your task is to fix the bug or implement the feature described above.

    You have not interacted with the REPL environment or seen your context yet. Your next action should be to explore the codebase - don't just provide a final answer yet.

    Think step-by-step on what to do using the REPL environment to solve the issue. Continue using the REPL environment, which has the `context` variable (containing the issue and repo path), and query sub-LLMs by writing ```repl``` code blocks.

    WORKFLOW:
    1. Explore: Understand the issue and find relevant files
    2. Analyze: Use llm_query() to understand the code
    3. Fix: Modify the file(s) using write_file()
    4. Submit: Call FINAL(done) after making your changes

    Start by exploring:

    ```repl
    # First, understand what we're working with
    print("=" * 50)
    print("ISSUE:")
    print("=" * 50)
    print(context["issue"])
    print("\n" + "=" * 50)
    print("REPO PATH:", context["repo_path"])
    ```

    Then explore the repository structure and find relevant files.
    
    REMEMBER: After you fix the code with write_file(), submit immediately with FINAL(done).

    Your next action:
    </instructions>

  max_iterations: 200
  step_limit: 200
  cost_limit: 1.0
  max_output_length: 50000

environment:
  cwd: "/testbed"
  timeout: 120
  env:
    PAGER: cat
    MANPAGER: cat
    LESS: -R
    PIP_PROGRESS_BAR: 'off'
    TQDM_DISABLE: '1'
  environment_class: docker

model:
  model_name: "gpt-4o"
  model_class: "rlm"
  model_kwargs:
    temperature: 0.0
