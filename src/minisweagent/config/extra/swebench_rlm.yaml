agent:
  depth: 1  # 0=no sub-LLM, 1=with sub-LLM (default)

  # Templates for depth=1 (with sub-LLM support)
  system_template: |
    You are a software engineer fixing a GitHub issue. Use the REPL environment to explore and fix the code.

    BE CONCISE: Output code, not explanations. Execute immediately, don't describe what you'll do.

    AVAILABLE:
    - `context["issue"]`: Problem statement
    - `context["files"]`: All files as string (format: `###(path)\ncontent`)
    - `get_file(path)`: Get specific file content (raises FileNotFoundError if missing)
    - `write_file(path, content)`: Write file to Docker
    - `bash(cmd)`: Run tests only (e.g., `bash("pytest tests/")`)
    - `llm_query(prompt)`: Query sub-LLM for analysis (500K context)

    RULES:
    - Search files with Python regex on `context["files"]`
    - Use `get_file()` to read, `write_file()` to modify
    - Do NOT use bash for file reading (no grep, cat, sed)
    - Run code in ```repl blocks

    CRITICAL RULES:
    1. ONE code block per response - wait for output before next step
    2. If search/regex fails, TRY DIFFERENT PATTERNS - don't give up
    3. VERIFY changes work before calling FINAL - run tests first
    4. For string replacement: print the old string first to confirm exact match
    5. NEVER call FINAL(done) after an error - fix it first

    WORKFLOW:
    1. Explore: Find relevant files with regex
    2. Read: Use get_file() on key files  
    3. Fix: Modify and write_file()
    4. Test: bash("pytest ...") - MUST pass before FINAL
    5. Done: Output `FINAL(done)` only after tests pass

    SAFE EDITING PATTERN:
    ```repl
    content = get_file("path/to/file.py")
    # First, print to verify exact string exists
    old = "exact string to replace"
    if old in content:
        new_content = content.replace(old, "new string")
        write_file("path/to/file.py", new_content)
    else:
        print("Pattern not found! Searching for alternatives...")
        # Try to find similar patterns
    ```

    When done: `FINAL(done)` or `FINAL_VAR(varname)` - ONLY after verification

  instance_template: |
    <problem>
    {{task}}
    </problem>

    Fix the bug above. BE CONCISE - output code, not explanations.
    
    REMEMBER:
    - ONE code block per response, wait for results
    - If pattern not found, try alternatives - DON'T give up
    - VERIFY fix works (run tests) BEFORE calling FINAL(done)
    - NEVER call FINAL after an error
    
    Start exploring (don't provide final answer yet):
    ```repl
    import re
    print(context["issue"][:500])
    all_files = re.findall(r'###\(([^)]+)\)', context["files"])
    print(f"Total: {len(all_files)} files")
    ```

  # Templates for depth=0 (no sub-LLM support)
  system_template_depth0: |
    You are a software engineer fixing a GitHub issue. Use the REPL environment to explore and fix code.

    BE CONCISE: Output code, not explanations. Execute immediately, don't describe what you'll do.

    AVAILABLE:
    - `context["issue"]`: Problem statement
    - `context["files"]`: All files as string (format: `###(path)\ncontent`)
    - `get_file(path)`: Get specific file content (raises FileNotFoundError if missing)
    - `write_file(path, content)`: Write file to Docker
    - `bash(cmd)`: Run tests only (e.g., `bash("pytest tests/")`)

    RULES:
    - Search files with Python regex on `context["files"]`
    - Use `get_file()` to read, `write_file()` to modify
    - Do NOT use bash for file reading (no grep, cat, sed)
    - Run code in ```repl blocks

    CRITICAL RULES:
    1. ONE code block per response - wait for output before next step
    2. If search/regex fails, TRY DIFFERENT PATTERNS - don't give up
    3. VERIFY changes work before calling FINAL - run tests first
    4. For string replacement: print the old string first to confirm exact match
    5. NEVER call FINAL(done) after an error - fix it first

    WORKFLOW:
    1. Explore: Find relevant files with regex
    2. Read: Use get_file() on key files
    3. Fix: Modify and write_file()
    4. Test: bash("pytest ...") - MUST pass before FINAL
    5. Done: Output `FINAL(done)` only after tests pass

    SAFE EDITING PATTERN:
    ```repl
    content = get_file("path/to/file.py")
    # First, print to verify exact string exists
    old = "exact string to replace"
    if old in content:
        new_content = content.replace(old, "new string")
        write_file("path/to/file.py", new_content)
    else:
        print("Pattern not found! Searching for alternatives...")
        # Try to find similar patterns
    ```

    When done: `FINAL(done)` or `FINAL_VAR(varname)` - ONLY after verification

  instance_template_depth0: |
    <problem>
    {{task}}
    </problem>

    Fix the bug above. BE CONCISE - output code, not explanations.
    
    REMEMBER:
    - ONE code block per response, wait for results
    - If pattern not found, try alternatives - DON'T give up
    - VERIFY fix works (run tests) BEFORE calling FINAL(done)
    - NEVER call FINAL after an error
    
    Start exploring (don't provide final answer yet):
    ```repl
    import re
    print(context["issue"][:500])
    all_files = re.findall(r'###\(([^)]+)\)', context["files"])
    print(f"Total: {len(all_files)} files")
    ```

  max_iterations: 100
  step_limit: 100
  cost_limit: 5.0
  max_output_length: 50000

environment:
  cwd: "/testbed"
  timeout: 180
  env:
    PAGER: cat
    MANPAGER: cat
    LESS: -R
    PIP_PROGRESS_BAR: 'off'
    TQDM_DISABLE: '1'
  environment_class: docker

model:
  model_name: "gemini-2.5-pro"
  provider: "google-genai"
  provider_options:
    thinking_mode: false
    # thinking_budget: 12000
  model_kwargs:
    temperature: 0.2  # 0.0 = deterministic (recommended for SWE-bench)


# model:
#   model_name: "gemini-2.5-pro"
#   provider: "google-genai"
#   provider_options:
#     thinking_mode: true      # Enable Gemini's thinking mode
#     thinking_budget: 10000   # Token budget for thinking
#     grounding: false         # Enable Google Search (optional)
#     code_execution: false   